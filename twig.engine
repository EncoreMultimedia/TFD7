<?php
/* Drupal implementation of the twig template engine.
 *
 * You *need* PHP 5.3.x or higher to use code.
 *
 * @version 7.0.1.3
 * @author RenÃ© Bakx
 *
 */


/**
 * Register the needed classes with the autoloader
 */

$autoloader = UniversalClassLoader::getInstance();
$autoloader->registerPrefixes(array(
    'Twig_' => DRUPAL_ROOT . '/sites/all/libraries',
    'TFD_' => DRUPAL_ROOT . '/sites/all/libraries',
));

/**
 * registers the .tpl.html extension for twig templates
 * @return string
 */
function twig_extension() {
    return ".tpl.twig";
}


/**
 * Implementation of hook_init()
 *
 * note get's called at rebuild registry!
 *
 * @param <object> $theme
 */
function twig_init($theme) {
    if (file_exists($file = dirname($theme->filename) . '/template.php')) {
        require_once($file);
    }
}

/**
 * Implementation of hook_theme()
 *
 * Registers both twig and php_template functions and templates
 * which is needed to perform the fallback to .tpl.php
 *
 * @link http://api.drupal.org/api/function/hook_theme/6
 * @return <array>
 */

function twig_theme($existing, $type, $theme, $path) {
    $templates = drupal_find_theme_functions($existing, array('twig', $theme));
    $templates += drupal_find_theme_templates($existing, twig_extension(), $path);
    return $templates;
}

/**
 * Implementation of hook ENGINE_render_template
 *
 * Checks if the twig template is available or else let drupal fallback to phptemplate
 *
 * @param <string> $template template filename
 * @param <array> $variables variables to be assigned to template
 * @return <string> rendered template
 */
function twig_render_template($template, $variables = array()) {
    $content = '';
    if (file_exists($template)) {
        try {
            $twig = twig_get_instance();
            $template = $twig->loadTemplate($template);
            $content = $template->render($variables);
        } catch (Exception $e) {
            $content = t('Twig error "!error"', array('!error' => $e->getMessage()));
        }
    } else {
        $content = t('Template (!template) not found ', array('!template' => $template));
    }
    return $content;
}

/**
 * Clears the entire template cache folder
 * @return void
 */
function twig_clear_cache() {
    twig_get_instance()->flushCompilerCache();
    watchdog('twig', 'All caches cleared');
}


/*
 * Returns a singleton version of the twig template engine
 * @return <object> Twig_Environment
*/
function twig_get_instance() {
    static $twig_engine;
    if (!is_object($twig_engine)) {
        global $theme_info;
        $twigEnvironment = array();
        $twigEnvironment['autoescape'] = false; // Automatically escape all output
        $twigEnvironment['auto_reload'] = true; //Whether to reload the template if the original source changed.
        $twigEnvironment['debug'] = false; // When set to `true`, the generated templates have a __toString() method
        $cache = 'public://twig_cache' . '/' . $theme_info->name;
        if ($cache) {
            $twigEnvironment['cache'] = $cache;
        }
        $loader = new TFD_Loader_Filesystem();
        $twig_engine = new TFD_Environment($loader, $twigEnvironment);
        $twig_engine->addExtension(new TFD_Extension());
    }
    return $twig_engine;
}

// Todo refactor into something like drupal_find_theme_templates();
function twig_get_discovered_templates() {
    $tplFolders = cache_get('twig_tpl_paths');
    if ($tplFolders->data == "") {
        $currentPath = drupal_get_path('theme', variable_get('theme_default', 'null'));
        $paths[] = $currentPath;
        $tplHooks = theme_get_registry();
        foreach ($tplHooks as $hook => $data) {
            if (is_array($data["theme paths"])) $paths = array_merge($paths, $data["theme paths"]);
            $paths[] = $data["theme path"];
        }
        $tempFolders = array_unique($paths);
        cache_set('twig_tpl_paths', $tempFolders, 'cache', CACHE_TEMPORARY);
        $return = $tempFolders;
    } else {
        $return = $tplFolders->data;
    }
    return $return;
}
