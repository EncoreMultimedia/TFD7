<?php

/**
 * @file
 * This file is part of Twig For Drupal 7.
 *
 * @author RenÃ© Bakx
 * @co-maintainer Pol Dellaiera
 *
 * @see http://tfd7.rocks for more information
 *
 * @version 7.x-3.x
 */

/**
 * Check if the needed classes can be autoloaded or not.
 * If they can be autoloaded it most likely means the site is under
 * composer-manager.
 */
if (!class_exists('TFD_Cache_Filesystem') && file_exists(__DIR__ . '/vendor/autoload.php')) {
  include_once __DIR__ . '/vendor/autoload.php';
}
else {
  throw new Exception('You need to run composer install before using TFD7');
}

/**
 * Registers the .tpl.twig extension for twig templates.
 *
 * @return string
 *   The template extension.
 */
function twig_extension() {
  return '.tpl.twig';
}

/**
 * Implementation of hook_init()
 *
 * Note: called at rebuild registry!
 */
function twig_init($theme) {
  if (file_exists($file = dirname($theme->filename) . '/template.php')) {
    require_once $file;
  }
}

/**
 * Implementation of hook_theme()
 *
 * Registers both twig and php_template functions and templates
 * which is needed to perform the fallback to .tpl.php.
 */
function twig_theme($existing, $type, $theme, $path) {
  $templates = drupal_find_theme_functions($existing, array($theme));
  $templates += drupal_find_theme_templates($existing, twig_extension(), $path);
  return $templates;
}

/**
 * Implementation of hook ENGINE_render_template.
 *
 * Checks if the twig template is available or else let drupal fallback to phptemplate.
 *
 * @param string $template
 *   template filename.
 * @param array $variables
 *   variables to be assigned to template.
 *
 * @return <string> rendered template
 */
function twig_render_template($template, $variables = array()) {
  $content = '';

  if (file_exists($template)) {
    try {
      $twig = twig_get_instance();
      $template = $twig->loadTemplate($template);
      $content = $template->render($variables);
    }
    catch (Exception $e) {
      $content = t('Twig error "!error"', array('!error' => $e->getMessage()));
      die($e->getMessage());
    }
  }
  else {
    $content = t('Template (!template) not found ', array('!template' => $template));
  }

  return $content;
}

/**
 * Clears the entire template cache folder.
 *
 * @return void
 */
function twig_clear_cache() {
  twig_get_cache_bin()->deleteAll();
  watchdog('twig', 'All caches cleared');
}

/**
 * Returns a singleton version of the twig template engine.
 *
 * @return TFD_Environment
 */
function twig_get_instance() {
  static $twig_engine;
  if (!is_object($twig_engine)) {
    $twigEnvironment = array();
    $twigEnvironment['autorender'] = variable_get('twig_autorender', TRUE);
    // Automatically escape all output.
    $twigEnvironment['autoescape'] = variable_get('twig_autoescape', FALSE);
    $twigEnvironment['auto_reload'] = variable_get('twig_auto_reload', TRUE);
    $twigEnvironment['debug'] = variable_get('theme_debug', FALSE);
    if (variable_get('twig_filecache', FALSE) == TRUE) {
      $twigEnvironment['cache'] = twig_get_cache_bin();
    }

    $loader = new TFD_Loader_Filesystem();
    $theme_names = twig_get_theme_paths();
    $loader->addPath(DRUPAL_ROOT);
    foreach ($theme_names as $theme_name => $path) {
      $templatesDirectory = DRUPAL_ROOT . DIRECTORY_SEPARATOR . $path . DIRECTORY_SEPARATOR . 'templates';
      if (is_dir($templatesDirectory)) {
        $loader->addPath($templatesDirectory, $theme_name);
      }
    }

    $twig_engine = new TFD_Environment($loader, $twigEnvironment);
    $twig_engine->addExtension(new TFD_Extension());
    drupal_alter('twig_init', $twig_engine);
  }

  return $twig_engine;
}

/**
 * Find templates in the current theme and the base theme
 * return an array where the paths are transformed into
 * theme::point/to/template.twig.tpl.
 *
 * Cache the implementations because this is a rather expensive
 * call which can occur multiple times per hit.
 *
 * The directory name 'templates' is omitted,
 * where else would the templates be ;)
 *
 * @return array (
 *                path/to/file = realpath,       // current theme
 *                (base)theme::path/to/file = realpath // parent/base theme
 *   )
 */
function twig_get_discovered_templates() {
  $implementations = &drupal_static(__FUNCTION__, array());
  if (!$implementations) {
    global $theme;
    $theme_paths = twig_get_theme_paths();
    $regex = '/' . str_replace('.', '\.', twig_extension()) . '$/';
    foreach ($theme_paths as $theme_name => $path) {
      $files = drupal_system_listing($regex, $path, 'name', 0);
      $theme_folder = '/themes/' . $theme_name . '/';
      foreach ($files as $template => $file) {
        $matches = explode($theme_folder, $file->uri);
        $converted_path = str_replace('templates/', '', $matches[1]);
        $realpath = dirname($file->uri) . '/' . $file->filename;

        if ($theme === $theme_name) {
          $implementations[$converted_path] = $realpath;
        }
        else {
          $implementations[$theme_name . '::' . $converted_path] = $realpath;
        }

      }
    }

  }
  return $implementations;
}

/**
 * @return array
 */
function twig_get_theme_paths() {
  global $theme;

  $available_themes    = list_themes();
  $available_themes[$theme]->info += array('base theme' => NULL);
  $theme_paths         = array();
  $theme_paths[$theme] = dirname($available_themes[$theme]->filename);
  $basethemes          = drupal_find_base_themes($available_themes, $theme);

  if (count($basethemes) > 0) {
    foreach (array_keys($basethemes) as $basename) {
      if (isset($available_themes[$basename])) {
        $theme_paths[$basename] = dirname($available_themes[$basename]->filename);
      }
    }
  }

  return $theme_paths;
}

/**
 * Tests if it is a writable directory to store the twig cache files in.
 *
 * @param string $scheme
 *   The scheme to validate.
 *
 * @return bool
 *   True is valid, otherwise False.
 */
function twig_cache_scheme_is_valid($scheme) {
  if (file_stream_wrapper_valid_scheme(file_uri_scheme($scheme))) {
    $scheme = drupal_dirname($scheme);
    if (is_dir($scheme) && is_writable($scheme)) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Get the cache scheme.
 *
 * @return string
 *   The scheme
 *
 * @throws ErrorException
 */
function twig_get_cache_scheme() {
  global $theme_info;
  $streamwrappers = file_get_stream_wrappers(STREAM_WRAPPERS_LOCAL_HIDDEN);

  if (isset($streamwrappers['twigcache'])) {
    return 'twigcache://';
  }
  elseif (variable_get('file_private_path', FALSE) == TRUE) {
    return 'private://twig_cache/' . $theme_info->name;
  }
  else {
    // Fallback and use the twig_cache folder in public://.
    return 'public://twig_cache/' . $theme_info->name;
  }
}

/**
 * Get the cache bin.
 *
 * @return TFD_Cache_Filesystem
 *   The cache bin.
 *
 * @throws ErrorException
 */
function twig_get_cache_bin() {
  static $cache_bin;

  if (!is_object($cache_bin)) {
    $cache_scheme = twig_get_cache_scheme();
    file_prepare_directory($cache_scheme, FILE_CREATE_DIRECTORY);

    $wrapper = file_stream_wrapper_get_instance_by_scheme(file_uri_scheme($cache_scheme));
    if (!twig_cache_scheme_is_valid($cache_scheme)) {
      $directory = $wrapper->getDirectoryPath();

      $message = t('Could not write in cache directory: @directory', array(
        '@directory' => $directory,
      )
      );

      watchdog('twig', $message, array(), WATCHDOG_ERROR);
      throw new ErrorException($message);
    }

    $cache_bin = new TFD_Cache_Filesystem($wrapper->getDirectoryPath());
  }

  return $cache_bin;
}
